<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统-操作系统-动态分区分配算法</title>
      <link href="/posts/d09db460.html"/>
      <url>/posts/d09db460.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h1><h2 id="首次适应算法-First-Fit"><a href="#首次适应算法-First-Fit" class="headerlink" title="首次适应算法(First Fit)"></a>首次适应算法(First Fit)</h2><p><img src="/../static/OS/35.1.png" alt="35.1"></p><h2 id="最佳适应算法-Best-Fit"><a href="#最佳适应算法-Best-Fit" class="headerlink" title="最佳适应算法(Best Fit)"></a>最佳适应算法(Best Fit)</h2><p><img src="/../static/OS/35.2.png" alt="35.2"></p><p><img src="/../static/OS/35.3.png" alt="35.3"></p><h2 id="最坏适应算法-Worst-Fit"><a href="#最坏适应算法-Worst-Fit" class="headerlink" title="最坏适应算法(Worst Fit)"></a>最坏适应算法(Worst Fit)</h2><p><img src="/../static/OS/35.4.png" alt="35.4"></p><p><img src="/../static/OS/35.5.png" alt="35.5"></p><h2 id="临近适应算法-Next-Fit"><a href="#临近适应算法-Next-Fit" class="headerlink" title="临近适应算法(Next Fit)"></a>临近适应算法(Next Fit)</h2><p><img src="/../static/OS/35.8.png" alt="35.8"></p><p><img src="/../static/OS/35.6.png" alt="35.6"></p><p><img src="/../static/OS/35.7.png" alt="35.7"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统-内存空间的分配与回收</title>
      <link href="/posts/c29bc9bd.html"/>
      <url>/posts/c29bc9bd.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h1><h2 id="连续分配管理方式-进程分配的空间必须是连续的"><a href="#连续分配管理方式-进程分配的空间必须是连续的" class="headerlink" title="连续分配管理方式(进程分配的空间必须是连续的)"></a>连续分配管理方式(进程分配的空间必须是连续的)</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p><img src="/../static/OS/34.1.png" alt="34.1"></p><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p><img src="/../static/OS/34.2.png" alt="34.2"></p><p><img src="/../static/OS/34.3.png" alt="34.3"></p><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p><img src="/../static/OS/34.4.png" alt="34.4"></p><p><img src="/../static/OS/34.5.png" alt="34.5"></p><p><img src="/../static/OS/34.6.png" alt="34.6"></p><p><img src="/../static/OS/34.7.png" alt="34.7"></p><h2 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h2>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统-覆盖与交换</title>
      <link href="/posts/a009ab56.html"/>
      <url>/posts/a009ab56.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h1><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p><img src="/../static/OS/33.1.png" alt="33.1"></p><p><img src="/../static/OS/33.2.png" alt="33.2"></p><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p><img src="/../static/OS/33.3.png" alt="33.3"></p><p><img src="/../static/OS/33.4.png" alt="33.4"></p><p><img src="/../static/OS/33.5.png" alt="33.5"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统-内存的基本知识</title>
      <link href="/posts/78617ef6.html"/>
      <url>/posts/78617ef6.html</url>
      
        <content type="html"><![CDATA[<p><img src="/../static/OS/32.1.png" alt="32.1"></p><p><img src="/../static/OS/32.2.png" alt="32.2"></p><p><img src="/../static/OS/32.3.png" alt="32.3"></p><p><img src="/../static/OS/32.4.png" alt="32.4"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统-内存的基本知识</title>
      <link href="/posts/78617ef6.html"/>
      <url>/posts/78617ef6.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存的基本知识"><a href="#内存的基本知识" class="headerlink" title="内存的基本知识"></a>内存的基本知识</h1><p><img src="/../static/OS/31.1.png" alt="31.1"></p><p><img src="/../static/OS/31.2.png" alt="31.2"></p><p><img src="/../static/OS/31.3.png" alt="31.3"></p><p><img src="/../static/OS/31.4.png" alt="31.4"></p><p><img src="/../static/OS/31.5.png" alt="31.5"></p><p><img src="/../static/OS/31.6.png" alt="31.6"></p><p><img src="/../static/OS/31.7.png" alt="31.7"></p><p><img src="/../static/OS/31.8.png" alt="31.8"></p><p><img src="/../static/OS/31.9.png" alt="31.9"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-set</title>
      <link href="/posts/91524b53.html"/>
      <url>/posts/91524b53.html</url>
      
        <content type="html"><![CDATA[<p>和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&lt;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt;, &lt;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&gt;, &lt;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&gt;&#125;</span><br></pre></td></tr></table></figure><p>set 容器定义于<code>&lt;set&gt;</code>头文件，并位于 std 命名空间中。因此如果想在程序中使用 set 容器，该程序代码应先包含如下语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p>begin() 和 end()：返回指向 set 集合的第一个元素和最后一个元素的迭代器。</p><p>empty()：如果 set 集合为空，则返回 true，否则返回 false。</p><p>size()：返回 set 集合中元素的数量。</p><p>insert(element)：在 set 集合中插入一个元素。</p><p>erase(element)：从 set 集合中删除某个元素。</p><p>clear()：清空 set 集合中的所有元素。</p><p>count(element)：如果 set 集合中存在某个元素，则返回 1，否则返回 0。</p><p>find(element)：在 set 集合中查找某个元素，如果存在则返回其迭代器，否则返回 end()。</p><p>lower_bound(element) 和 upper_bound(element)：返回第一个不小于指定元素的迭代器（lower_bound）和第一个大于指定元素的迭代器（upper_bound）。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统-检测和解除</title>
      <link href="/posts/a285052d.html"/>
      <url>/posts/a285052d.html</url>
      
        <content type="html"><![CDATA[<h1 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h1><h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><p><img src="/../static/OS/30.1.png" alt="30.1"></p><p><img src="/../static/OS/30.2.png" alt="30.2"></p><p><img src="/../static/OS/30.3.png" alt="30.3"></p><h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p><img src="/../static/OS/30.4.png" alt="30.4"></p><p><img src="/../static/OS/30.5.png" alt="30.5"></p><p><img src="/../static/OS/30.6.png" alt="30.6"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统-避免死锁</title>
      <link href="/posts/77e9e571.html"/>
      <url>/posts/77e9e571.html</url>
      
        <content type="html"><![CDATA[<h1 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h1><p><img src="/../static/OS/29.1.png" alt="29.1"></p><p><img src="/../static/OS/29.2.png" alt="29.2"></p><p><img src="/../static/OS/29.3.png" alt="29.3"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统-预防死锁</title>
      <link href="/posts/a725773d.html"/>
      <url>/posts/a725773d.html</url>
      
        <content type="html"><![CDATA[<h1 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h1><p><img src="/../static/OS/28.1.png" alt="28.1"></p><p><img src="/../static/OS/28.2.png" alt="28.2"></p><p><img src="/../static/OS/28.3.png" alt="28.3"></p><p><img src="/../static/OS/28.4.png" alt="28.4"></p><p><img src="/../static/OS/28.5.png" alt="28.5"></p><p><img src="/../static/OS/28.6.png" alt="28.6"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的死锁的概念</title>
      <link href="/posts/ca594063.html"/>
      <url>/posts/ca594063.html</url>
      
        <content type="html"><![CDATA[<h1 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h1><p><img src="/../static/OS/27.1.png" alt="27.1"></p><p><img src="/../static/OS/27.2.png" alt="27.2"></p><p><img src="/../static/OS/27.3.png" alt="27.3"></p><p><img src="/../static/OS/27.4.png" alt="27.4"></p><p><img src="/../static/OS/27.5.png" alt="27.5"></p><p><img src="/../static/OS/27.6.png" alt="27.6"></p><p><img src="/../static/OS/27.7.png" alt="27.7"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的管程</title>
      <link href="/posts/941b5c6a.html"/>
      <url>/posts/941b5c6a.html</url>
      
        <content type="html"><![CDATA[<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><h2 id="管程的定义和基本特征"><a href="#管程的定义和基本特征" class="headerlink" title="管程的定义和基本特征"></a>管程的定义和基本特征</h2><p><img src="/../static/OS/26.1.png" alt="26.1"></p><p><img src="/../static/OS/26.2.png" alt="26.2"></p><p><img src="/../static/OS/26.4.png" alt="26.4"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网-媒体接入控制的基本概念</title>
      <link href="/posts/f90c031d.html"/>
      <url>/posts/f90c031d.html</url>
      
        <content type="html"><![CDATA[<h1 id="媒体接入控制的基本概念"><a href="#媒体接入控制的基本概念" class="headerlink" title="媒体接入控制的基本概念"></a>媒体接入控制的基本概念</h1>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网-点对点协议PPP</title>
      <link href="/posts/40205be2.html"/>
      <url>/posts/40205be2.html</url>
      
        <content type="html"><![CDATA[<h1 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h1><p> <img src="/../static/jw/28.1.png" alt="28.1"></p><p><img src="/../static/jw/28.2.png" alt="28.2"></p><p><img src="/../static/jw/28.3.png" alt="28.3"></p><p><img src="/../static/jw/28.4.png" alt="28.4"></p><p><img src="/../static/jw/28.5.png" alt="28.5"></p><p><img src="/../static/jw/28.6.png" alt="28.6"></p><p><img src="/../static/jw/28.7.png" alt="28.7"></p>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网-可靠传输的实现机制</title>
      <link href="/posts/4d027344.html"/>
      <url>/posts/4d027344.html</url>
      
        <content type="html"><![CDATA[<h1 id="可靠传输的实现机制-不局限于数据链路层"><a href="#可靠传输的实现机制-不局限于数据链路层" class="headerlink" title="可靠传输的实现机制(不局限于数据链路层)"></a>可靠传输的实现机制(不局限于数据链路层)</h1><h2 id="停止等待协议SW"><a href="#停止等待协议SW" class="headerlink" title="停止等待协议SW"></a>停止等待协议SW</h2><p><img src="/../static/jw/25.1.png" alt="25.1"></p><p><img src="/../static/jw/25.2.png" alt="25.2"></p><p>在数据链路层，点对点传输中不会出现确认迟到的情况，所以不需要给确认分组编号，</p><p><img src="/../static/jw/25.5.png" alt="25.5"></p><p><img src="/../static/jw/25.4.png" alt="25.4"></p><h2 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h2><p>累计确认：<img src="/../static/OS/25.6.png" alt="25.6"></p><p><img src="/../static/jw/25.7.png" alt="25.7"></p><p><img src="/../static/jw/25.8.png" alt="25.8"></p><h2 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h2><p>接收方不在采用累积确认</p><p><img src="/../static/jw/25.9.png" alt="25.9"></p>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-链表</title>
      <link href="/posts/adca56ac.html"/>
      <url>/posts/adca56ac.html</url>
      
        <content type="html"><![CDATA[<p>采用虚拟头结点时，建议所有新开的结点从虚拟头结点开始，少判断空指针。</p><p>链表的遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">ListNode* cur=head;</span><br><span class="line"><span class="keyword">while</span> (cur)&#123;</span><br><span class="line">内容;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除链表中指定的元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除头结点</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123; <span class="comment">// 注意这里不是if</span></span><br><span class="line">            ListNode* tmp = head;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除非头结点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next!= <span class="literal">NULL</span>) &#123; <span class="comment">//当cur到最后一个元素时</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统-吸烟者问题，读者写者问题</title>
      <link href="/posts/771fd09a.html"/>
      <url>/posts/771fd09a.html</url>
      
        <content type="html"><![CDATA[<h1 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h1><p><img src="/../static/OS/24.1.png" alt="24.1"></p><h1 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h1><p><img src="/../static/OS/24.2.png" alt="24.2"></p><p><img src="/../static/OS/24.3.png" alt="24.3"></p><p><img src="/../static/OS/24.4.png" alt="24.4"></p><h1 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h1><p><img src="/../static/OS/24.5.png" alt="24.5"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统-生产者消费者问题</title>
      <link href="/posts/1410d79e.html"/>
      <url>/posts/1410d79e.html</url>
      
        <content type="html"><![CDATA[<h1 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h1><img src="../static/OS/23.1.png" alt="23.1"  /><h1 id="多生产者多消费者问题"><a href="#多生产者多消费者问题" class="headerlink" title="多生产者多消费者问题"></a>多生产者多消费者问题</h1><p><img src="/../static/OS/23.2.png" alt="23.2"></p><p><img src="/../static/OS/23.3.png" alt="23.3"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网-数据链路层的概述</title>
      <link href="/posts/848a9a80.html"/>
      <url>/posts/848a9a80.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层的概述"><a href="#数据链路层的概述" class="headerlink" title="数据链路层的概述"></a>数据链路层的概述</h1><p>链路：就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</p><p>数据链路：是指把实现通信协议的硬件和软件加到链路上，就构成了数据链路。</p><p>数据链路层以帧为单位传输和处理数据。</p><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>封装帧头帧尾</p><p>帧头帧尾的作用之一就是帧定界，并不是所有帧都有帧定界。没有帧定界的帧会在物理层时在帧前添加前导码，前导码中包含前同步码和真开始定界符，MAC帧，规定了帧间隔时间96比特的发送时间，所以不需要帧结束定界符。</p><p><img src="/../static/jw/20.1.png" alt="20.1"></p><p><img src="/../static/jw/21.3.png" alt="21.3"></p><p><img src="/../static/jw/21.4.png" alt="21.4"></p><p><img src="/../static/jw/21.5.png" alt="21.5"></p><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p><img src="/../static/jw/21.6.png" alt="21.6"></p><p>帧尾有检错码，接收方通过检错码来判断帧中是否有误码。</p><p>有误码的帧后则会丢弃</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>在待发送的数据后面添加一位奇偶校验位，使整个数据(包括所添加的校验位在内)中”1”的个数为奇数或偶数。<img src="/../static/jw/21.7.png" alt="21.7"></p><h3 id="循环冗余校验CRC"><a href="#循环冗余校验CRC" class="headerlink" title="循环冗余校验CRC"></a>循环冗余校验CRC</h3><p><img src="/../static/jw/21.8.png" alt="21.8"></p><p><img src="/../static/jw/21.9.png" alt="21.9"></p><p><img src="/../static/jw/21.10.png" alt="21.10"></p><p><img src="/../static/jw/21.11.png" alt="21.11"></p><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p><img src="/../static/jw/21.1.png" alt="21.1"></p><p><img src="/../static/jw/21.2.png" alt="21.2"></p><p><img src="/../static/jw/22.2.png" alt="22.2"></p><p><img src="/../static/jw/22.3.png" alt="22.3"></p>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法经验</title>
      <link href="/posts/a4b89a7d.html"/>
      <url>/posts/a4b89a7d.html</url>
      
        <content type="html"><![CDATA[<p><strong>匹配（消除）问题也是栈的擅长所在。</strong></p><p><strong>给你一个元素，判断这个元素在这个集合是否出现过  —用哈希表</strong></p><p><strong>采用虚拟头结点时，建议所有新开的结点从虚拟头结点开始，少判断空指针。</strong></p><p><strong>需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章</strong></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String常用库函数</title>
      <link href="/posts/febdf129.html"/>
      <url>/posts/febdf129.html</url>
      
        <content type="html"><![CDATA[<p>pop_back() 删除源字符串的最后一个字符，有效的减少它的长度。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统-用信号量机制实现进程互斥，同步，前驱关系。</title>
      <link href="/posts/4c58f37f.html"/>
      <url>/posts/4c58f37f.html</url>
      
        <content type="html"><![CDATA[<h1 id="用信号量机制实现进程互斥，同步，前驱关系。"><a href="#用信号量机制实现进程互斥，同步，前驱关系。" class="headerlink" title="用信号量机制实现进程互斥，同步，前驱关系。"></a>用信号量机制实现进程互斥，同步，前驱关系。</h1><h2 id="实现进程互斥"><a href="#实现进程互斥" class="headerlink" title="实现进程互斥"></a>实现进程互斥</h2><p><img src="/../static/OS/22.1.png" alt="22.1"></p><h2 id="实现进程同步"><a href="#实现进程同步" class="headerlink" title="实现进程同步"></a>实现进程同步</h2><p><img src="/../static/OS/22.2.png" alt="22.2"></p><p><img src="/../static/OS/22.3.png" alt="22.3"></p><h2 id="实现进程前驱关系"><a href="#实现进程前驱关系" class="headerlink" title="实现进程前驱关系"></a>实现进程前驱关系</h2><p><img src="/../static/OS/22.4.png" alt="22.4"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/22.5.png" alt="22.5"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的信号量机制</title>
      <link href="/posts/7c101fcb.html"/>
      <url>/posts/7c101fcb.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的信号量机制"><a href="#操作系统的信号量机制" class="headerlink" title="操作系统的信号量机制"></a>操作系统的信号量机制</h1><p><img src="/../static/OS/21.1.png" alt="21.1"></p><h2 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h2><p><img src="/../static/OS/21.2.png" alt="21.2"></p><h2 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h2><p><img src="/../static/OS/21.3.png" alt="21.3"></p><p><img src="/../static/OS/21.4.png" alt="21.4"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/21.5.png" alt="21.5"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的进程互斥的硬件实现方法</title>
      <link href="/posts/c07daf48.html"/>
      <url>/posts/c07daf48.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h1><h2 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h2><p><img src="/../static/OS/20.1.png" alt="20.1"></p><h2 id="TestAndSet-TS指令-x2F-TSL指令"><a href="#TestAndSet-TS指令-x2F-TSL指令" class="headerlink" title="TestAndSet(TS指令&#x2F;TSL指令)"></a>TestAndSet(TS指令&#x2F;TSL指令)</h2><p><img src="/../static/OS/20.2.png" alt="20.2"></p><h2 id="Swap指令-XCHG指令"><a href="#Swap指令-XCHG指令" class="headerlink" title="Swap指令(XCHG指令)"></a>Swap指令(XCHG指令)</h2><p><img src="/../static/OS/20.3.png" alt="20.3"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/20.4.png" alt="20.4"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的进程互斥的软件实现方法</title>
      <link href="/posts/9d834efe.html"/>
      <url>/posts/9d834efe.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h1><h2 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h2><p>两个进程在访问完临界区后会吧使用临界区的权限交给另一个进程。也就是说进入临界区的权限只能被另一个进程赋予。</p><p>违背空闲让进的原则。</p><h2 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h2><p>设置一个布尔类型的数组，来标记各个进程想进入临界区的意愿。</p><p>违背了忙则等待的原则。</p><p>原因：进入区检查和上锁不是原子操作，会发生进程切换，导致违背忙则等待原则。</p><h2 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h2><p>虽然解决了忙则等待，但是违背了空闲让进和有限等待的原则，产生饥饿现象。</p><h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><p><img src="/../static/OS/19.1.png" alt="19.1"></p><p><img src="/../static/OS/19.2.png" alt="19.2"></p><p><img src="/../static/OS/19.3.png" alt="19.3"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/19.4.png" alt="19.4"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的进程同步与进程互斥</title>
      <link href="/posts/e5d16f48.html"/>
      <url>/posts/e5d16f48.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程同步与进程互斥"><a href="#进程同步与进程互斥" class="headerlink" title="进程同步与进程互斥"></a>进程同步与进程互斥</h1><p><img src="/../static/OS/18.1.png" alt="18.1"></p><p><img src="/../static/OS/18.2.png" alt="18.2"></p><p><img src="/../static/OS/18.3.png" alt="18.3"></p><p><img src="/../static/OS/18.4.png" alt="18.4"></p><p><img src="/../static/OS/18.5.png" alt="18.5"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/18.6.png" alt="18.6"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网-信道的极限容量</title>
      <link href="/posts/183234e3.html"/>
      <url>/posts/183234e3.html</url>
      
        <content type="html"><![CDATA[<h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><p>码间串扰：信号波形失去了码元之间清晰的界线。</p><p><img src="/../static/jw/18.1.png" alt="18.1"></p><p><img src="/../static/jw/18.2.png" alt="18.2"></p><p><img src="/../static/jw/18.3.png" alt="18.3"></p><p><img src="/../static/jw/18.4.png" alt="18.4"></p>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网-编码与调制</title>
      <link href="/posts/70e0cfaa.html"/>
      <url>/posts/70e0cfaa.html</url>
      
        <content type="html"><![CDATA[<h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p><img src="/../static/jw/17.1.png" alt="17.1"></p><p><img src="/../static/jw/17.2.png" alt="17.2"></p><p><img src="/../static/jw/17.3.png" alt="17.3"></p><h2 id="基本的调制方法"><a href="#基本的调制方法" class="headerlink" title="基本的调制方法"></a>基本的调制方法</h2><p><img src="/../static/jw/17.4.png" alt="17.4"></p><p><img src="/../static/jw/17.5.png" alt="17.5"></p>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网-传输方式</title>
      <link href="/posts/c9d36541.html"/>
      <url>/posts/c9d36541.html</url>
      
        <content type="html"><![CDATA[<h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><h2 id="串行传输"><a href="#串行传输" class="headerlink" title="串行传输"></a>串行传输</h2><p>一条线路  计算机网络中使用串行传输</p><h2 id="并行传输"><a href="#并行传输" class="headerlink" title="并行传输"></a>并行传输</h2><p>多条线路   速度是串行传输的N倍 ，成本高   电脑内部使用并行传输  </p><h2 id="同步传输"><a href="#同步传输" class="headerlink" title="同步传输"></a>同步传输</h2><p><img src="/../static/jw/16.1.png" alt="16.1"></p><h2 id="异步传输"><a href="#异步传输" class="headerlink" title="异步传输"></a>异步传输</h2><p><img src="/../static/jw/16.2.png" alt="16.2"></p><h3 id="单向通信-单工"><a href="#单向通信-单工" class="headerlink" title="单向通信(单工)"></a>单向通信(单工)</h3><p>单向 一条信道</p><p>如：无线电广播 </p><h3 id="双向交替通信-半双工"><a href="#双向交替通信-半双工" class="headerlink" title="双向交替通信(半双工)"></a>双向交替通信(半双工)</h3><p>可以双向进行，但是不能同时进行 两条信道</p><p>如：对讲机</p><h3 id="双向同时通信-全双工"><a href="#双向同时通信-全双工" class="headerlink" title="双向同时通信(全双工)"></a>双向同时通信(全双工)</h3><p>可以同时发送和接受  两条信道</p><p>如：电话</p>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网-络物理层的基本概念</title>
      <link href="/posts/a8b4fca.html"/>
      <url>/posts/a8b4fca.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网-络物理层的基本概念"><a href="#计算机网-络物理层的基本概念" class="headerlink" title="计算机网-络物理层的基本概念"></a>计算机网-络物理层的基本概念</h1><p><img src="/../static/jw/14.1.png" alt="14.1"></p><p>传输媒体不属于计算机网络体系的任何一层。</p><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="/../static/jw/15.1.png" alt="15.1"></p><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p><img src="/../static/jw/15.2.png" alt="15.2"></p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="/../static/jw/15.3.png" alt="15.3"></p><p><img src="/../static/jw/15.4.png" alt="15.4"></p><h3 id="电力线"><a href="#电力线" class="headerlink" title="电力线"></a>电力线</h3><p><img src="/../static/jw/15.5.png" alt="15.5"></p><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><h3 id="无线电波"><a href="#无线电波" class="headerlink" title="无线电波"></a>无线电波</h3><p><img src="/../static/jw/15.6.png" alt="15.6"></p><h3 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h3><p>频率范围：300MHz-300GHz(波长1m-1mm) 主要使用2-40GHz范围</p><p>微波会穿过电离层</p><p><img src="/../static/jw/15.7.png" alt="15.7"></p><h3 id="红外线"><a href="#红外线" class="headerlink" title="红外线"></a>红外线</h3><p>点对点无线传输</p><p>直线传输，中间不能有障碍物，传输距离短</p><p>传输速率低（4Mb&#x2F;s~16Mb&#x2F;s）</p><h3 id="可见光"><a href="#可见光" class="headerlink" title="可见光"></a>可见光</h3>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-二分</title>
      <link href="/posts/17ef395a.html"/>
      <url>/posts/17ef395a.html</url>
      
        <content type="html"><![CDATA[<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>二分的使用条件</p><p><strong>这题目为LeetCode中704二分查找    前提是数组为有序数组</strong>，同时题目还强调<strong>数组中无重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。</p><p><img src="/../static/Algorithm/%E7%AE%97%E6%B3%95%E8%A1%A8%E7%A4%BA%E7%89%B9%E7%82%B9/%E4%BA%8C%E5%88%86.png" alt="二分"></p><p>关于二分的一些边界问题。</p><p>1，首先确定我们使用的区间是哪种类型</p><p>2，根据类型写判断条件</p><p>以左闭右闭为例。[1,1]这种区间是合法区间 ，代码（题目为LeetCode中704二分查找）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;   <span class="comment">//可以加上等于号，因为区间合法</span></span><br><span class="line">            <span class="type">int</span> middle=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&gt;target)&#123;  <span class="comment">//判断条件中已经排除middle的值，所以更新区间是不包括。</span></span><br><span class="line">                r=middle<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&lt;target)&#123;</span><br><span class="line">                l=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以左闭右开为例。[1,1)这种区间是非法法区间 ，代码（题目为LeetCode中704二分查找）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>(); <span class="comment">//因为右边为开区间，所以r=nums.size();</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;  <span class="comment">// [1,1)这种区间是非法法区间，不加等于号</span></span><br><span class="line">            <span class="type">int</span> middle=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle]&gt;target)&#123;<span class="comment">//有边界开区间 r=middle</span></span><br><span class="line">                r=middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle]&lt;target)&#123;<span class="comment">//左边闭区间 判断条件中已经排除middle的值，所以更新区间是不包括。</span></span><br><span class="line">                l=middle+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同理其他区间也用类似分析方法。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的调度算法</title>
      <link href="/posts/e5d16f48.html"/>
      <url>/posts/e5d16f48.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的调度算法"><a href="#操作系统的调度算法" class="headerlink" title="操作系统的调度算法"></a>操作系统的调度算法</h1><h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><p><img src="/../static/OS/17.1.png" alt="17.1"></p><p><img src="/../static/OS/17.2.png" alt="17.2"></p><h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><p><img src="/../static/OS/17.3.png" alt="17.3"></p><p><img src="/../static/OS/17.4.png" alt="17.4"></p><p><img src="/../static/OS/17.5.png" alt="17.4"></p><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p><img src="/../static/OS/17.6.png" alt="17.6"></p><p><img src="/../static/OS/17.7.png" alt="17.7"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/17.8.png" alt="17.8"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的三种调度算法</title>
      <link href="/posts/4272acbc.html"/>
      <url>/posts/4272acbc.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的三种调度算法"><a href="#操作系统的三种调度算法" class="headerlink" title="操作系统的三种调度算法"></a>操作系统的三种调度算法</h1><p>饥饿：某进程或作业长时间得不到服务。</p><h2 id="先来先服务（FCFS"><a href="#先来先服务（FCFS" class="headerlink" title="先来先服务（FCFS)"></a>先来先服务（FCFS)</h2><p><img src="/../static/OS/16.1.png" alt="16.1"></p><p><img src="/../static/OS/16.2.png" alt="16.2"></p><h2 id="短作业优先（SJF）"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h2><p><img src="/../static/OS/16.3.png" alt="16.3"></p><p><img src="/../static/OS/16.4.png" alt="16.4"></p><p><img src="/../static/OS/16.5.png" alt="16.5"></p><p><img src="/../static/OS/16.6.png" alt="16.6"></p><h2 id="高响应比优先（HRRN）"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a>高响应比优先（HRRN）</h2><p><img src="/../static/OS/16.7.png" alt="16.7"></p><p><img src="/../static/OS/16.8.png" alt="16.8"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/16.9.png" alt="16.7"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统调度算法的评价指标</title>
      <link href="/posts/439b1f28.html"/>
      <url>/posts/439b1f28.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统调度算法的评价指标"><a href="#操作系统调度算法的评价指标" class="headerlink" title="操作系统调度算法的评价指标"></a>操作系统调度算法的评价指标</h1><h2 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a>CPU利用率</h2><p><img src="/../static/OS/15.1.png" alt="15.1"></p><h2 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a>系统吞吐量</h2><p><img src="/../static/OS/15.2.png" alt="15.2"></p><h2 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h2><h3 id="周转时间，平均周转时间"><a href="#周转时间，平均周转时间" class="headerlink" title="周转时间，平均周转时间"></a>周转时间，平均周转时间</h3><p><img src="/../static/OS/15.3.png" alt="15.3"></p><h3 id="带权周转时间，平均带权周转时间"><a href="#带权周转时间，平均带权周转时间" class="headerlink" title="带权周转时间，平均带权周转时间"></a>带权周转时间，平均带权周转时间</h3><p><img src="/../static/OS/15.5.png" alt="15.4"></p><h2 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a>等待时间</h2><p><img src="/../static/OS/15.6.png" alt="15.6"></p><h2 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h2><p>用户提交到首次产生响应所用的时间</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/15.7.png" alt="15.7"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统进程调度的时机,切换与过程，方式</title>
      <link href="/posts/10120f25.html"/>
      <url>/posts/10120f25.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统进程调度的时机-切换与过程，方式"><a href="#操作系统进程调度的时机-切换与过程，方式" class="headerlink" title="操作系统进程调度的时机,切换与过程，方式"></a>操作系统进程调度的时机,切换与过程，方式</h1><h2 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h2><p><img src="/../static/OS/14.3.png" alt="14.3"></p><h3 id="什么时候需要进程调度？"><a href="#什么时候需要进程调度？" class="headerlink" title="什么时候需要进程调度？"></a>什么时候需要进程调度？</h3><p><img src="/../static/OS/14.1.png" alt="14.1"></p><h3 id="什么时候不能进行进程调度？"><a href="#什么时候不能进行进程调度？" class="headerlink" title="什么时候不能进行进程调度？"></a>什么时候不能进行进程调度？</h3><p><img src="/../static/OS/14.2.png" alt="14.2"></p><h2 id="切换与过程"><a href="#切换与过程" class="headerlink" title="切换与过程"></a>切换与过程</h2><h3 id="狭义的调度与切换的区别"><a href="#狭义的调度与切换的区别" class="headerlink" title="狭义的调度与切换的区别"></a>狭义的调度与切换的区别</h3><p><img src="/../static/OS/14.6.png" alt="14.6"></p><h3 id="进程切换的过程需要做什么？"><a href="#进程切换的过程需要做什么？" class="headerlink" title="进程切换的过程需要做什么？"></a>进程切换的过程需要做什么？</h3><p><img src="/../static/OS/14.7.png" alt="14.7"></p><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><h3 id="非剥夺调度方式（非抢占式）"><a href="#非剥夺调度方式（非抢占式）" class="headerlink" title="非剥夺调度方式（非抢占式）"></a>非剥夺调度方式（非抢占式）</h3><p><img src="/../static/OS/14.4.png" alt="14.4"></p><h3 id="剥夺调度方式（抢占式）"><a href="#剥夺调度方式（抢占式）" class="headerlink" title="剥夺调度方式（抢占式）"></a>剥夺调度方式（抢占式）</h3><p><img src="/../static/OS/14.5.png" alt="14.5"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/14.8.png" alt="14.8"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统处理机调度的概念、层次</title>
      <link href="/posts/6a85fdf2.html"/>
      <url>/posts/6a85fdf2.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统处理机调度的概念、层次"><a href="#操作系统处理机调度的概念、层次" class="headerlink" title="操作系统处理机调度的概念、层次"></a>操作系统处理机调度的概念、层次</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>当有一堆任务要处理是，但是由于资源有限，这些事情没法同时处理，这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是调度研究的问题。</p><p>在多道程序系统中，进程的数量往往是多于处理机的个数，这样不可能同时并行的处理各个进程。<strong>处理机调度</strong>就是从就绪队列中按照一定算法选择一个进程并将处理机分配给其运行，以实现进程的并发执行。</p><h2 id="三个层次"><a href="#三个层次" class="headerlink" title="三个层次"></a>三个层次</h2><h3 id="高级调度（作业调度）"><a href="#高级调度（作业调度）" class="headerlink" title="高级调度（作业调度）"></a>高级调度（作业调度）</h3><p>按照一定的原则从外存上处于后备队列的作业挑选一个或多个作业，给她们分配内存等资源，并建立相应的进程(建立PCB)，以使它们获得竞争处理机的权利。</p><p><img src="/../static/OS/13.2.png" alt="13.2"></p><h3 id="中级调度（内存调度）"><a href="#中级调度（内存调度）" class="headerlink" title="中级调度（内存调度）"></a>中级调度（内存调度）</h3><p><img src="/../static/OS/13.3.png" alt="13.3"></p><h3 id="低级调度（进程调度）"><a href="#低级调度（进程调度）" class="headerlink" title="低级调度（进程调度）"></a>低级调度（进程调度）</h3><p> 低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给他。</p><p>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度，进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</p><h2 id="三层调度的联系与对比"><a href="#三层调度的联系与对比" class="headerlink" title="三层调度的联系与对比"></a>三层调度的联系与对比</h2><p><img src="/../static/OS/13.5.png" alt="13.5"></p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><h3 id="进程的“-挂起态”七状态模型"><a href="#进程的“-挂起态”七状态模型" class="headerlink" title="进程的“ 挂起态”七状态模型"></a>进程的“ 挂起态”七状态模型</h3><p><img src="/../static/OS/13.4.png" alt="13.4"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/13.6.png" alt="13.6"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记</title>
      <link href="/posts/bba1d2c5.html"/>
      <url>/posts/bba1d2c5.html</url>
      
        <content type="html"><![CDATA[<p>sting 用printf输出     </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">string str=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str.<span class="built_in">c_str</span>());    <span class="comment">// 调用c_str()函数</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将数组转set</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(a.begin(), a.end())</span></span>;</span><br></pre></td></tr></table></figure><p>与map不同，set中数据只能通过<code>insert()</code>函数进行插入。</p><p>reverse语法 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(begin, begin + n)</span><br></pre></td></tr></table></figure><p>n是翻转元素的个数</p><p>翻转范围为<code>[begin,begin + n)</code>，是左闭右开区间 </p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统线程概念 多线程模型</title>
      <link href="/posts/b525ef3.html"/>
      <url>/posts/b525ef3.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统线程概念-多线程模型"><a href="#操作系统线程概念-多线程模型" class="headerlink" title="操作系统线程概念 多线程模型"></a>操作系统线程概念 多线程模型</h1><h2 id="什么是线程，为什么要引入线程？"><a href="#什么是线程，为什么要引入线程？" class="headerlink" title="什么是线程，为什么要引入线程？"></a>什么是线程，为什么要引入线程？</h2><p>传统的进程是程序执行流的最小单位。</p><p>引入线程后线程称为了程序执行流的最小单位</p><p><img src="/../static/OS/12.1.png" alt="12.1"></p><p><img src="/../static/OS/12.2.png" alt="12.2"></p><h2 id="引入线程机制后，有什么变化？"><a href="#引入线程机制后，有什么变化？" class="headerlink" title="引入线程机制后，有什么变化？"></a>引入线程机制后，有什么变化？</h2><p><img src="/../static/OS/12.3.png" alt="12.3"></p><h2 id="线程有哪些重要的属性？"><a href="#线程有哪些重要的属性？" class="headerlink" title="线程有哪些重要的属性？"></a>线程有哪些重要的属性？</h2><p><img src="/../static/OS/12.4.png" alt="12.4"></p><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><p>​</p><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p><img src="/../static/OS/12.5.png" alt="12.5"></p><h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p><img src="/../static/OS/12.6.png" alt="12.6"></p><p><img src="/../static/OS/12.7.png" alt="12.7"></p><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><h3 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h3><p><img src="/../static/OS/12.8.png" alt="12.8"></p><h3 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h3><p><img src="/../static/OS/12.9.png" alt="12.9"></p><h3 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h3><p><img src="/../static/OS/12.10.png" alt="12.10"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/12.11.png" alt="12.11"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统进程的通信</title>
      <link href="/posts/a92916fe.html"/>
      <url>/posts/a92916fe.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统进程的通信"><a href="#操作系统进程的通信" class="headerlink" title="操作系统进程的通信"></a>操作系统进程的通信</h1><p>进程通信指进程之间的信息交换。</p><h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>分配一个共享空间，访问是互斥的（操作系统同步互斥工具实现的 如P,V操作）</p><h3 id="1，基于数据结构的共享"><a href="#1，基于数据结构的共享" class="headerlink" title="1，基于数据结构的共享"></a>1，基于数据结构的共享</h3><p>只能存放一个固定的数据结构。</p><p>共享速度慢限制多低级通信。</p><h3 id="2，基于存储区的共享"><a href="#2，基于存储区的共享" class="headerlink" title="2，基于存储区的共享"></a>2，基于存储区的共享</h3><p>速度快高级通信</p><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>进程见的数据交换以格式化的信息为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息”两个原语进行数据交换，</p><h3 id="1，直接通信"><a href="#1，直接通信" class="headerlink" title="1，直接通信"></a>1，直接通信</h3><p>消息直接被挂到消息缓冲队列中，</p><h3 id="2，间接通信"><a href="#2，间接通信" class="headerlink" title="2，间接通信"></a>2，间接通信</h3><p>消息要先发送到中间实体中</p><h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><p>管道是指用于连接读和写进程的一个共享文件，其实就是在内存中开辟一个固定大小的缓冲区。</p><p><img src="/../static/OS/11.1.png" alt="11.1"></p><p><img src="/../static/OS/11.2.png" alt="11.2"></p><p><img src="/../static/OS/11.4.png" alt="11.4"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/11.5.png" alt="11.5"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统进程的控制</title>
      <link href="/posts/f71875f2.html"/>
      <url>/posts/f71875f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统进程的控制"><a href="#操作系统进程的控制" class="headerlink" title="操作系统进程的控制"></a>操作系统进程的控制</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是进程控制："><a href="#什么是进程控制：" class="headerlink" title="什么是进程控制："></a>什么是进程控制：</h3><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程，撤销已有进程，实现进程状态转换等功能。简单理解就是实现进程转换。</p><h3 id="如何实现进程控制"><a href="#如何实现进程控制" class="headerlink" title="如何实现进程控制"></a>如何实现进程控制</h3><p>用<strong>原语</strong>实现进程控制。特点是**执行期间不允许中断，只能一气呵成。 **原子操作</p><p>采用关中断，开中断实现。核心态下执行的特权指令。</p><p><img src="/../static/OS/10.1.png" alt="10.1"></p><p>进程控制相关的原语：</p><p><img src="/../static/OS/10.2.png" alt="10.2"></p><p><img src="/../static/OS/10.3.png" alt="10.3"></p><p><img src="/../static/OS/10.4.png" alt="10.4"></p><p><img src="/../static/OS/10.5.png" alt="10.5"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../static/OS/10.6.png" alt="10.6"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统进程的状态与转换</title>
      <link href="/posts/dc2ced6b.html"/>
      <url>/posts/dc2ced6b.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统进程的状态与转换"><a href="#操作系统进程的状态与转换" class="headerlink" title="操作系统进程的状态与转换"></a>操作系统进程的状态与转换</h1><h2 id="状态："><a href="#状态：" class="headerlink" title="状态："></a>状态：</h2><p>三种基本状态：</p><p>运行态：占有cpu，并在cpu上运行</p><p>就绪态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行（进程已经拥有除了处理机以外的所有需要的资源，一旦获得处理机即可立即进入运行态）</p><p>阻塞态：因等待某一事件而暂时不能运行</p><p>另外两种状态：</p><p>创建态：进程正在被创建，操作系统为其分配资源初始化PCB</p><p>终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源，撤销PCB</p><h2 id="进程状态的转化"><a href="#进程状态的转化" class="headerlink" title="进程状态的转化"></a>进程状态的转化</h2><p><img src="/../static/OS/9.1.png" alt="9.1"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../static/OS/9.2.png" alt="9.2"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统进程的定义组成组织方式特征</title>
      <link href="/posts/a4db76fd.html"/>
      <url>/posts/a4db76fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统进程的定义组成组织方式特征"><a href="#操作系统进程的定义组成组织方式特征" class="headerlink" title="操作系统进程的定义组成组织方式特征"></a>操作系统进程的定义组成组织方式特征</h1><h2 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h2><p>程序：一个指令序列</p><p><img src="/../static/OS/5.12.png" alt="5.12"></p><p><img src="/../static/OS/5.13.png" alt="5.13"></p><h2 id="进程-进程实体-的组成"><a href="#进程-进程实体-的组成" class="headerlink" title="进程(进程实体)的组成"></a>进程(进程实体)的组成</h2><p>程序段，数据段，PCB</p><p><img src="/../static/OS/5.14.png" alt="5.14"></p><p>PCB所包含的信息</p><p><img src="/../static/OS/5.15.png" alt="5.15"></p><h2 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h2><p><img src="/../static/OS/5.16.png" alt="5.16"></p><p><img src="/../static/OS/5.17.png" alt="5.17"></p><p><img src="/../static/OS/5.18.png" alt="5.18"></p><h2 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h2><p><img src="/../static/OS/5.19.png" alt="5.19"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../static/OS/5.20.png" alt="5.20"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的系统调用</title>
      <link href="/posts/d8b653d0.html"/>
      <url>/posts/d8b653d0.html</url>
      
        <content type="html"><![CDATA[<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="什么是系统调用，有何作用？"><a href="#什么是系统调用，有何作用？" class="headerlink" title="什么是系统调用，有何作用？"></a>什么是系统调用，有何作用？</h2><p><img src="/../static/OS/5.7.png" alt="5.7"></p><h2 id="系统调用与库函数的区别"><a href="#系统调用与库函数的区别" class="headerlink" title="系统调用与库函数的区别"></a>系统调用与库函数的区别</h2><p><img src="/../static/OS/5.8.png" alt="5.8"></p><h2 id="系统调用背后的过程"><a href="#系统调用背后的过程" class="headerlink" title="系统调用背后的过程"></a>系统调用背后的过程</h2><p>​<img src="/../static/OS/5.10.png" alt="5.10"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/../static/OS/5.11.png" alt="5.11"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的中断和异常</title>
      <link href="/posts/b87d75b9.html"/>
      <url>/posts/b87d75b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><h2 id="中断的本质："><a href="#中断的本质：" class="headerlink" title="中断的本质："></a>中断的本质：</h2><p>发生<strong>中断</strong>就意味着需要<strong>操作系统的介入</strong>，<strong>开展管理工作</strong>。</p><p>当中断发生是，cpu立即进入核心态</p><p>当中断发生后，当前运行的进程暂停运行，并由操作系统对中断进行处理。</p><p>对于不同的中断信号，会进行不同的处理</p><p><strong>用户态到核心态的切换：通过中断实现的，并且<em>中断</em>是唯一途径。</strong></p><p><strong>核心态到用户态的切换</strong>：<strong>执行一条特权指令，设置程序状态字PSW为用户态。</strong></p><h3 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h3><p><img src="/../static/OS/5.3.png" alt="5.3"></p><p><img src="/../static/OS/5.4.png" alt="5.4"></p><h3 id="外中断的处理过程："><a href="#外中断的处理过程：" class="headerlink" title="外中断的处理过程："></a>外中断的处理过程：</h3><p><img src="/../static/OS/5.6.png" alt="5.6"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/5.5.png" alt="5.5"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的运行机制与体系结构</title>
      <link href="/posts/859eb638.html"/>
      <url>/posts/859eb638.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的运行机制与体系结构"><a href="#操作系统的运行机制与体系结构" class="headerlink" title="操作系统的运行机制与体系结构"></a>操作系统的运行机制与体系结构</h1><p><img src="/../static/OS/5.png" alt="5"></p><p>指令：</p><p>特权指令：如内存清零指令 不允许用户程序使用</p><p>非特权指令：如普通的运算指令 </p><p>处理器的两种状态(用程序状态寄存器PSW中的某标志位来标识当前状态，如0为用户态，1为核心态)：</p><p>用户态(目态)：此时CPU只能执行非特权指令</p><p>核心态(管态)：此时CPU可以执行特权指令非特权指令</p><p>两种程序：</p><p>内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态；</p><p>应用程序：为了保证系统安全，只能执行非特权指令，运行在用户态</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="内核-是计算机配置的底层软件，是操作系统最基本最核心的部分-："><a href="#内核-是计算机配置的底层软件，是操作系统最基本最核心的部分-：" class="headerlink" title="内核(是计算机配置的底层软件，是操作系统最基本最核心的部分)："></a>内核(是计算机配置的底层<strong>软件</strong>，是操作系统最基本最核心的部分)：</h3><h3 id="实现操作系统内核功能的那些程序就是内核程序。"><a href="#实现操作系统内核功能的那些程序就是内核程序。" class="headerlink" title="实现操作系统内核功能的那些程序就是内核程序。"></a>实现操作系统内核功能的那些程序就是内核程序。</h3><p><strong>时钟管理</strong>：实现计时功能</p><p><strong>中断处理</strong>：实现中断机制</p><p><strong>对系统资源进行管理的功能</strong>(有的操作系统不将这部分功能划分为内核部分，不同系统划分不一样，包含叫大内核，不包含则叫微内核：</p><p>1，进程管理</p><p>2，存储器管理</p><p>3，设备管理等功能、</p><p>**原语(设备驱动，cpu切换…)**：</p><p>1，原语是一种特殊的程序</p><p>2，是最接近硬件的部分</p><p>3，这种程序的运行具有<strong>原子性</strong> –运行是只能一气呵成不能中断</p><p>4，运行时间较短，调用频繁</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/OS/5.1.png" alt="5.1"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网络体系结构</title>
      <link href="/posts/21da0718.html"/>
      <url>/posts/21da0718.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h2><h3 id="OSI体系结构-法律上的标准-："><a href="#OSI体系结构-法律上的标准-：" class="headerlink" title="OSI体系结构(法律上的标准)："></a>OSI体系结构(法律上的标准)：</h3><p><img src="/../static/jw/16.png" alt="16"></p><h3 id="TCP-x2F-IP体系结构-事实上的国际标准-："><a href="#TCP-x2F-IP体系结构-事实上的国际标准-：" class="headerlink" title="TCP&#x2F;IP体系结构(事实上的国际标准)："></a>TCP&#x2F;IP体系结构(事实上的国际标准)：</h3><p><img src="/../static/jw/18.png" alt="18"></p><h3 id="原理体系结构："><a href="#原理体系结构：" class="headerlink" title="原理体系结构："></a>原理体系结构：</h3><p><img src="/../static/jw/19.png" alt="19"></p><h2 id="计算机网络体系结构分成的必要性"><a href="#计算机网络体系结构分成的必要性" class="headerlink" title="计算机网络体系结构分成的必要性"></a>计算机网络体系结构分成的必要性</h2><p>物理层：使用何种信号来传输比特的问题</p><p>数据链路层：解决在一个网络上传输的问题</p><p>网络层：解决在多个网络上的问题</p><p>运输层: 解决进程之间基于网络通信的问题</p><p>表示层：解决进程之间进行会话的问题</p><p>表示层：解决双方交换信息的表示问题</p><p>应用层：解决通过应用进程的交互来实现特定的网络应用的问题</p><h2 id="计算机网络体系结构分层思想举例"><a href="#计算机网络体系结构分层思想举例" class="headerlink" title="计算机网络体系结构分层思想举例"></a>计算机网络体系结构分层思想举例</h2><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=9&vd_source=c7973f7aaa9987eb9fcf41cb657ed598">https://www.bilibili.com/video/BV1c4411d7jb?p=9&amp;vd_source=c7973f7aaa9987eb9fcf41cb657ed598</a></p><h2 id="计算机网络体系结构中的专用术语"><a href="#计算机网络体系结构中的专用术语" class="headerlink" title="计算机网络体系结构中的专用术语"></a>计算机网络体系结构中的专用术语</h2><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>任何可发送或接收信息的硬件或软件进程</p><h2 id="对等实体"><a href="#对等实体" class="headerlink" title="对等实体"></a>对等实体</h2><p>收发双方相同层次中的实体</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>控制两个对等实体进行逻辑通信的规则的集合</p><p>协议的三个要素：语法，语义，同步</p><p>语法：定义交换信息的格式</p><p>语义：定义收发双方所要完成的操作</p><p>同步：定义收发双方的时序关系</p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。</p><p>要实现本层协议，还需要使用下面一层所提供的服务；</p><p>协议是<strong>水平的</strong>，服务是<strong>垂直的</strong></p><p>实体是看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议，下面的协议对上面的实体是<strong>透明</strong>的</p><h2 id="服务访问点"><a href="#服务访问点" class="headerlink" title="服务访问点"></a>服务访问点</h2><p><img src="/../static/jw/2.1.png" alt="2.1"></p><p><img src="/../static/jw/2.2.png" alt="2.2"></p><p><img src="/../static/jw/2.3.png" alt="2.3"></p>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网络的性能与指标</title>
      <link href="/posts/939e4f55.html"/>
      <url>/posts/939e4f55.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络的性能与指标"><a href="#计算机网络的性能与指标" class="headerlink" title="计算机网络的性能与指标"></a>计算机网络的性能与指标</h1><h2 id="数据量单位："><a href="#数据量单位：" class="headerlink" title="数据量单位："></a>数据量单位：</h2><p><strong>8bit&#x3D;1Byte</strong></p><p><strong>KB&#x3D;2的十次方B</strong></p><p><strong>MB&#x3D;2的20次方B</strong></p><p><strong>GB&#x3D;2的30次方B</strong></p><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p> 连接在计算机网络上的主机在数字信道上传送比特的速率，也称为<strong>比特率或数据率</strong>。</p><p><img src="/../static/jw/10.png" alt="10"></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><h3 id="带宽在模拟信号系统中的意义："><a href="#带宽在模拟信号系统中的意义：" class="headerlink" title="带宽在模拟信号系统中的意义："></a>带宽在模拟信号系统中的意义：</h3><p>信号所包含的各种不同频率成分所占据的频率范围；单位 Hz。</p><h3 id="带宽在计算机网络中的意义："><a href="#带宽在计算机网络中的意义：" class="headerlink" title="带宽在计算机网络中的意义："></a>带宽在计算机网络中的意义：</h3><p>用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中某一点到另一点所能通过的<strong>最高数据率</strong>；单位 b&#x2F;s kb&#x2F;s Mb&#x2F;s 同速率单位。</p><p>带宽越宽表示传输的最高数据率也越高。</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量表示在<strong>单位时间内通过某个网络(或信道，接口)的数据量。</strong></p><p>吞吐量<strong>受网络带宽或额定速率的限制</strong></p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><h3 id="1发送时延"><a href="#1发送时延" class="headerlink" title="1发送时延"></a>1发送时延</h3><p>分组长度(b)&#x2F;发送速率(b&#x2F;s)</p><h3 id="2传播时延"><a href="#2传播时延" class="headerlink" title="2传播时延"></a>2传播时延</h3><p>信道长度(m)&#x2F;电磁波传播速率(m&#x2F;s)          </p><p>电磁波的传播速率： </p><p>在自由空间中：3*10^8 m&#x2F;s</p><p>在铜线中：2.3*10^8 m&#x2F;s</p><p>在光纤中：2.0*10^8 m&#x2F;s</p><h3 id="3处理时延"><a href="#3处理时延" class="headerlink" title="3处理时延"></a>3处理时延</h3><p>一般不方便计算    处理为动态变化。</p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>传播时延*带宽</p><p><img src="/../static/jw/12.png" alt="12"></p><h2 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h2><p><img src="/../static/jw/13.png" alt="13"></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>用来表示某信道有百分之几的时间是被利用的(有数据通过)</p><h3 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h3><p>全网络的信道利用率的加权平均。</p><h3 id="根据排队论，当某信道的利用率曾大时，该信道引起的时延也会增加"><a href="#根据排队论，当某信道的利用率曾大时，该信道引起的时延也会增加" class="headerlink" title="根据排队论，当某信道的利用率曾大时，该信道引起的时延也会增加"></a>根据排队论，当某信道的利用率曾大时，该信道引起的时延也会增加</h3><h3 id="因此，信道利用率不是越高越好；"><a href="#因此，信道利用率不是越高越好；" class="headerlink" title="因此，信道利用率不是越高越好；"></a>因此，信道利用率不是越高越好；</h3><p><img src="/../static/jw/14.png" alt="14"></p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>丢包率即分组丢失率，是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比例。</p><p>丢包率具体可分为接口丢包率，结点丢包率，链路丢包率，路劲丢包率，网络丢包率；</p><h4 id="分组丢失："><a href="#分组丢失：" class="headerlink" title="分组丢失："></a>分组丢失：</h4><p>1分组在传输过程中出现误码，被结点丢失。</p><p>2分组到达一台队列已满的分组交换机时被丢弃；在通信量较大是就可能造成<strong>网络堵塞</strong>。</p><p>无拥塞是路劲丢包率0</p><p>轻度拥塞为1%-4%</p><p>严重拥塞为5%-15%</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/../static/jw/11.png" alt="11"></p><p><img src="/../static/jw/15.png" alt="15"></p>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的发展与分类</title>
      <link href="/posts/899d52e1.html"/>
      <url>/posts/899d52e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h1><h2 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h2><p>主要缺点：用户独占全机，人机速度矛盾导致资源利用率低。</p><h2 id="批处理阶段-单道批处理系统"><a href="#批处理阶段-单道批处理系统" class="headerlink" title="批处理阶段-单道批处理系统"></a>批处理阶段-单道批处理系统</h2><p>主要优点：缓解了人机，速度矛盾 ，资源利用率提高</p><p>主要缺点：内存中<strong>仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序，<strong>CPU有大量时间空闲在等待IO完成</strong>，资源利用率依然很低。</p><h2 id="☆批处理阶段-多道批处理系统"><a href="#☆批处理阶段-多道批处理系统" class="headerlink" title="☆批处理阶段-多道批处理系统"></a><strong>☆</strong>批处理阶段-多道批处理系统</h2><h2 id="操作系统正式诞生，引入了中断技术"><a href="#操作系统正式诞生，引入了中断技术" class="headerlink" title="操作系统正式诞生，引入了中断技术"></a>操作系统正式诞生，引入了中断技术</h2><p>主要优点：多道程序<strong>并发</strong>执行（操作系统负责管理调度资源），<strong>共享</strong>计算机资源，内存中可以读入多道程序。资源利用率大幅度提升，系统吞吐量增大。</p><p>主要缺点：用户响应时间长，没有人机交互功能。</p><h2 id="☆分时操作系统"><a href="#☆分时操作系统" class="headerlink" title="☆分时操作系统"></a><strong>☆</strong>分时操作系统</h2><p>主要优点：<strong>用户请求可以被即时响应，解决人机交互</strong>。允许多个用户使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p>主要缺点：<strong>不能优先处理一些紧急任务</strong>，不区分任务的紧急性。</p><h2 id="☆实时操作系统"><a href="#☆实时操作系统" class="headerlink" title="☆实时操作系统"></a><strong>☆</strong>实时操作系统</h2><p>主要优点：能够优先响应一些紧急任务。</p><h3 id="☆硬实时操作系统"><a href="#☆硬实时操作系统" class="headerlink" title="☆硬实时操作系统"></a><strong>☆</strong>硬实时操作系统</h3><p>必须严格在规定的时间内完成处理。</p><h3 id="☆软实时操作系统"><a href="#☆软实时操作系统" class="headerlink" title="☆软实时操作系统"></a><strong>☆</strong>软实时操作系统</h3><p>能偶尔违反时间规定。</p><p><img src="/../static/OS/4.png" alt="4"></p><p><img src="/../static/OS/4.1.png" alt="4.1"></p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的特征</title>
      <link href="/posts/8d9e58a9.html"/>
      <url>/posts/8d9e58a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><h1 id="并发共享为最基本特征，两者互为存在条件"><a href="#并发共享为最基本特征，两者互为存在条件" class="headerlink" title="(并发共享为最基本特征，两者互为存在条件)"></a>(并发共享为最基本特征，两者互为<strong>存在条件</strong>)</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发 ***"></a>并发 ***</h2><p>并发：指两个或多个事件在<strong>同一时间间隔内发生</strong>，这些时间宏观上是同时发生，但微观上是<strong>交替发生</strong>的。</p><p>并行：指两个或多个事件<strong>同时发生</strong>。</p><p>操作系统的并发性：指计算机系统中同时存在着多个运行着的程序。</p><h2 id="共享"><a href="#共享" class="headerlink" title="共享 ***"></a>共享 ***</h2><p>共享：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p>1 互斥共享：</p><p>​系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong>。</p><p>​</p><p>2 同时共享：</p><p>​系统中的某些 资源，允许一个时间段内由<strong>多个进程“同时”对他们进行访问。</strong></p><p>​</p><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上的对应物后者是用户感受的。</p><p>虚拟存储技术（空间复用技术）</p><p>虚拟处理器技术（时分复用技术）</p><p><strong>没有并发性，就谈不上虚拟性</strong></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p> 异步：</p><pre><code> 是指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</code></pre><h3 id="没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征。"><a href="#没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征。" class="headerlink" title="没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征。"></a><strong>没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征。</strong></h3>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-操作系统的概念功能和目标</title>
      <link href="/posts/385b55c.html"/>
      <url>/posts/385b55c.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的概念，功能和目标"><a href="#操作系统的概念，功能和目标" class="headerlink" title="操作系统的概念，功能和目标"></a>操作系统的概念，功能和目标</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>操作系统是指<strong>控制和管理整个计算机系统的硬件和软件资源</strong>，并<strong>合理地组织调度计算机的工作和资源分配</strong>，<strong>以提供给用户和其他软件方便的接口和环境</strong>，他是计算机系统中最基本的<strong>系统软件</strong>。</p><h2 id="功能和目标"><a href="#功能和目标" class="headerlink" title="功能和目标"></a>功能和目标</h2><h3 id="系统资源的管理者："><a href="#系统资源的管理者：" class="headerlink" title="系统资源的管理者："></a>系统资源的管理者：</h3><p>提供的功能:</p><ol><li><strong>处理机管理</strong> <strong>(CPU管理)</strong></li><li><strong>存储器管理</strong> <strong>(内存管理)</strong></li><li><strong>文件管理</strong></li><li><strong>设备管理</strong>   (例如摄像头)</li></ol><p>目标：</p><ol><li><strong>安全高效</strong></li></ol><h3 id="作为用户和计算机硬件之间的接口"><a href="#作为用户和计算机硬件之间的接口" class="headerlink" title="作为用户和计算机硬件之间的接口"></a>作为用户和计算机硬件之间的接口</h3><p>提供的功能：</p><ol><li><p><strong>命令接口(允许用户直接使用):</strong></p><ul><li>联机命令接口 （j交互式命令接口）：用户说一句 系统做一句   (cmd交互)</li><li>脱机命令接口 （批处理命令接口 ）：用户说一堆 系统做一堆   (.bat文件)</li></ul></li><li><p><strong>程序接口(允许用户通过程序间接使用)</strong>    <strong>(程序接口&#x3D;系统调用&#x3D;广义指令)</strong>      （.dll文件）</p></li><li><p>GUI（图形用户界面）</p></li></ol><p>目标：</p><p>​<strong>方便用户使用</strong></p><h3 id="作为最接近硬件的层次"><a href="#作为最接近硬件的层次" class="headerlink" title="作为最接近硬件的层次"></a>作为最接近硬件的层次</h3><p>提供的功能：<strong>实现对硬件机器的拓展</strong></p><p>目标：</p><p>​方便用户使用</p>]]></content>
      
      
      <categories>
          
          <category> os </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-计算机网络的定义和分类</title>
      <link href="/posts/34100421.html"/>
      <url>/posts/34100421.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络的定义与分离"><a href="#计算机网络的定义与分离" class="headerlink" title="计算机网络的定义与分离"></a>计算机网络的定义与分离</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><img src="/../static/jw/7.png" alt="7"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><img src="/../static/jw/8.png" alt="8"></p>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-三种交换方式</title>
      <link href="/posts/68f126cf.html"/>
      <url>/posts/68f126cf.html</url>
      
        <content type="html"><![CDATA[<h1 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h1><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>无电话交换机：  电话22相连 需要n*(n-1)&#x2F;2这么多线。</p><ul><li><p>电话交换机接通电话线的方式称为电路交换；</p></li><li><p>从通信资源的分配角度来看，交换就是按照某种方式动态的分配传输线路的资源</p></li><li><p>电路交换的三个步骤</p><p>1 建立连接(分配资源)</p><p>2 通话(一直占用通信资源)</p><p>3 释放连接(归还通信资源)</p></li><li><p>能否用电路交换来传输计算机数据</p><p>答：不行，通信效率低</p></li></ul><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p><img src="/../static/jw/5.png" alt="5"></p><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><p>用于早起电报通信网</p><p>不限制报文大小 需要各结点交换机都具有较大的缓存空间</p><h2 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h2><p><img src="/../static/jw/6.png" alt="6"></p>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-因特网的概述</title>
      <link href="/posts/ff6ea241.html"/>
      <url>/posts/ff6ea241.html</url>
      
        <content type="html"><![CDATA[<h1 id="因特网的概述"><a href="#因特网的概述" class="headerlink" title="因特网的概述"></a>因特网的概述</h1><h2 id="1网络，互联网和因特网"><a href="#1网络，互联网和因特网" class="headerlink" title="1网络，互联网和因特网"></a>1网络，互联网和因特网</h2><ul><li>网络由若干个<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成</li><li>多个网络还可以通过路由器互联起来，这样就构成了一个覆盖范围更大的网络，即互联网。因此，互联网是<strong>网络的网络</strong>。</li><li>因特网是世界上最大的互连网络。</li><li><img src="/../static/jw/1.png" alt="因特网的概述1"></li><li><img src="/../static/jw/2.png" alt="因特网的概述2"></li></ul><h2 id="2因特网发展的三个阶段"><a href="#2因特网发展的三个阶段" class="headerlink" title="2因特网发展的三个阶段"></a>2因特网发展的三个阶段</h2><p><img src="/../static/jw/3.png" alt="因特网的概述3"></p><p>因特网服务提供者(中国)：电信 联通 移动</p><h2 id="3因特网的标准化工作"><a href="#3因特网的标准化工作" class="headerlink" title="3因特网的标准化工作"></a>3因特网的标准化工作</h2><p><img src="/../static/jw/4.png" alt="4"></p><p>只有少部分RFC文档成为因特网标准。</p><h2 id="4因特网的组成"><a href="#4因特网的组成" class="headerlink" title="4因特网的组成"></a>4因特网的组成</h2><ul><li><p>边缘部分</p><p>由所有连接在因特网上的<strong>主机</strong>组成，这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>和<strong>资源共享</strong></p></li><li><p>核心部分</p><p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的(提供连通性和交换)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> jw </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒假集训c++基础与STL库</title>
      <link href="/posts/3d706849.html"/>
      <url>/posts/3d706849.html</url>
      
        <content type="html"><![CDATA[<p><strong>scanf()</strong> 可输入不包含空格的字符串，不读取回车，空格和回车表示输入完毕。</p><p><strong>getchar()</strong> 只能读取用户输入缓存区的一个字符，包括回车。</p><p>**getline()**用法:</p><p>它遇到以下情况发生会导致生成的本字符串结束：<br>(1)到文件结束，(2)遇到函数的定界符，(3)输入达到最大限度</p><h2 id="万能头文件"><a href="#万能头文件" class="headerlink" title="万能头文件"></a>万能头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体类型名字（<span class="type">int</span>） &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">double</span> dd;</span><br><span class="line">&#125;结尾可以直接命名;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef  结构体类型名字 &#123;</span><br><span class="line">内容</span><br><span class="line">&#125;stl(这里是相当于给结构体换了个名字,与上面不同);</span><br></pre></td></tr></table></figure><p><img src="/../static/%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="结构体"></p><p><img src="/../static/Algorithm/%E9%87%8D%E8%BD%BD%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="重载结构体运算符"></p><h1 id="STL库"><a href="#STL库" class="headerlink" title="STL库"></a>STL库</h1><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><img src="/../static/Algorithm/%E5%AD%97%E7%AC%A6%E4%B8%B2.png" alt="字符串"></p><p>cin cout遇到空格就停止<img src="/../static/Algorithm/%E8%AF%BB%E5%85%A5.png" alt="读入"></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="头文件-include-万能头文件中包含"><a href="#头文件-include-万能头文件中包含" class="headerlink" title="头文件#include  万能头文件中包含"></a>头文件#include<stack>  万能头文件中包含</h3><h3 id="命名空间-std-后进先出"><a href="#命名空间-std-后进先出" class="headerlink" title="命名空间 std 后进先出"></a>命名空间 std 后进先出</h3><p>定义一个int型的栈  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//入栈</span></span><br><span class="line">s.<span class="built_in">pop</span>();<span class="comment">//弹出 无返回值</span></span><br><span class="line"><span class="type">int</span> stacktop = s.<span class="built_in">top</span>();<span class="comment">//取栈首</span></span><br><span class="line"><span class="type">bool</span> isempty = s.<span class="built_in">empty</span>();<span class="comment">//判断栈内是否为空;</span></span><br><span class="line"><span class="type">int</span> stacksize = s.<span class="built_in">size</span>();<span class="comment">//栈内元素数</span></span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="include-万能头文件中包含"><a href="#include-万能头文件中包含" class="headerlink" title="#include 万能头文件中包含"></a>#include<queue> 万能头文件中包含</h3><h3 id="命名空间-std-先进先出"><a href="#命名空间-std-先进先出" class="headerlink" title="命名空间 std 先进先出"></a>命名空间 std 先进先出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;<span class="comment">//定义一个队列</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//入队</span></span><br><span class="line">q.<span class="built_in">pop</span>();<span class="comment">//弹出</span></span><br><span class="line"><span class="type">int</span> qfront = q.<span class="built_in">front</span>();<span class="comment">//取队首</span></span><br><span class="line"><span class="type">int</span> qback = q.<span class="built_in">back</span>();<span class="comment">//取队尾</span></span><br><span class="line"><span class="type">bool</span> isempty = q.<span class="built_in">empty</span>();<span class="comment">//判断队内是否为空;</span></span><br><span class="line"><span class="type">int</span> qsize = q.<span class="built_in">size</span>();<span class="comment">//队内元素数量</span></span><br></pre></td></tr></table></figure><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">默认大顶端,先输出大数据</span><br></pre></td></tr></table></figure><p><img src="/../static/Algorithm/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png" alt="优先队列"></p><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p><img src="/../static/Algorithm/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.png" alt="双端队列"></p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p><img src="/../static/Algorithm/%E5%90%91%E9%87%8F.png" alt="向量"></p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><img src="/../static/Algorithm/map.png" alt="map"></p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p><img src="/../static/Algorithm/%E9%9B%86%E5%90%88.png" alt="集合"></p><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p><img src="/../static/Algorithm/%E8%A1%A8.png" alt="表"></p><p><img src="/../static/Algorithm/%E8%A1%A82.png" alt="表2"></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/posts/d87f7e0c.html"/>
      <url>/posts/d87f7e0c.html</url>
      
        <content type="html"><![CDATA[<h1 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h1><h3 id="思想-分治，代码用的双指针"><a href="#思想-分治，代码用的双指针" class="headerlink" title="思想(分治，代码用的双指针):"></a>思想(分治，代码用的双指针):</h3><p>1.确定中间点(与快速排序算法不同，快速排序确定的是中间值，归并排序确定的是中间点).</p><p>2.先递归处理左右两边.</p><p>3.合并排序(双指针)</p><h3 id="归并排序的特性："><a href="#归并排序的特性：" class="headerlink" title="归并排序的特性："></a>归并排序的特性：</h3><p>归并排序的时间复杂度是 <strong>O（nlogn）</strong>且这个时间复杂度是稳定的(与快速排序不同)，不随需要排序的序列不同而产生波动。 </p><p>递归是<strong>O(logn)</strong></p><p>遍历是<strong>O(n)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> q[N],temp[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;q[j]) temp[k++]=q[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++]=q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) temp[k++]=q[j++];</span><br><span class="line">    <span class="keyword">for</span> (i = l,j=<span class="number">0</span>; i &lt;=r; i ++,j++ ) q[i]=temp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; q[i] &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序模板</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<h1 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h1><h2 id="思想（分治）："><a href="#思想（分治）：" class="headerlink" title="思想（分治）："></a>思想（分治）：</h2><p>1.确定基准值(一般选择中间值);</p><p>2.排序(左边的值小于基准值，右边的值大于基准值)</p><p>3.递归处理.</p><h2 id="快速排序的特点及性能"><a href="#快速排序的特点及性能" class="headerlink" title="快速排序的特点及性能"></a>快速排序的特点及性能</h2><p>时间复杂度：最坏的情况下O(n²),平均时间复杂度(nlogn)。</p><p>快速排序是一个不稳定的算法，在经过排序之后，可能会对相同值的元素的相对位置造成改变。</p><p>快速排序基本上被认为是相同数量级的所有排序算法中，平均性能最好的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x=q[(l+r)/<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> i=l<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; q[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* CDN 服务仅供平台体验和调试使用，平台不承诺服务的稳定性，企业客户需下载字体包自行发布使用并做好备份。 */@font-face {  font-family: "yyyy";  font-weight: 400;  src: url("/font/1.woff");  font-style: normal;  font-display: block;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 导航栏魔改 *//* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {  text-shadow: 0 0 2px var(rgb(127 255 212)) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {  text-shadow: 0 0 2px var(rgb(127 255 212)) !important;}/* 闪烁变动颜色连续渐变 */#site-name,#site-title,#site-subtitle,#post-info,.author-info__name,.author-info__description {  transition: text-shadow 1s linear !important;}/* 导航栏魔改 *//* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -50px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/runtime.css"/>
      <url>/css/runtime.css</url>
      
        <content type="html"><![CDATA[/*电子钟字体*/@font-face {    font-family: 'UnidreamLED';    src: url("https://cdn.jsdelivr.net/npm/akilar-candyassets/fonts/UnidreamLED.ttf");    font-display: swap;  }  div#runtime {    width: 180px;    margin: auto;    color: #fff;    padding-inline: 5px;    border-radius: 10px;    background-color: rgba(0,0,0,0.7);    font-family: 'UnidreamLED';  }  [data-theme="dark"] div#runtime {    color: #28b4c8;    box-shadow: 0 0 5px rgba(28,69,218,0.71);    animation: flashlight 1s linear infinite alternate;  }  /*悬停显示徽标提示语*/  a.github-badge:hover:before {    position: fixed;    width: fit-content;    margin: auto;    left: 0;    right: 0;    top: 10%;    border-radius: 10px;    text-align: center;    z-index: 100;    content: attr(data-title);    font-size: 20px;    color: #fff;    padding: 10px;    background-color: var(--text-bg-hover);  }  [data-theme=dark] a.github-badge:hover:before {    background-color: rgba(18,18,18,0.8);  }  @-moz-keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }  @-webkit-keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }  @-o-keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }  @keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {    // 仅夜间模式才启用    if (document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark') {        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px";            document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px";        } catch {                    }        idx++;        if (idx == 8) {            idx = 0;        }    } else {        // 白天模式恢复默认        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = "";            document.getElementsByClassName("author-info__description")[0].style.textShadow = "";        } catch {                    }    }}// 开启计时器window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[setInterval(() => {    let create_time = Math.round(new Date('2023-01-12 00:00:00').getTime() / 1000); //在此行修改建站时间    let timestamp = Math.round((new Date().getTime()) / 1000);    let second = timestamp - create_time;    let time = new Array(0, 0, 0, 0, 0);      var nol = function(h){      return h>9?h:'0'+h;    }    if (second >= 365 * 24 * 3600) {      time[0] = parseInt(second / (365 * 24 * 3600));      second %= 365 * 24 * 3600;    }    if (second >= 24 * 3600) {      time[1] = parseInt(second / (24 * 3600));      second %= 24 * 3600;    }    if (second >= 3600) {      time[2] = nol(parseInt(second / 3600));      second %= 3600;    }    if (second >= 60) {      time[3] = nol(parseInt(second / 60));      second %= 60;    }    if (second > 0) {      time[4] = nol(second);    }    if ((Number(time[2])<22) && (Number(time[2])>7)){      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/糖果屋-营业中-6adea8?style=social&logo=cakephp' title='距离百年老店也就差不到一百年~'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    else{      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/糖果屋-打烊了-6adea8?style=social&logo=coffeescript' title='这个点了应该去睡觉啦，熬夜对身体不好哦'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    document.getElementById("workboard").innerHTML = currentTimeHtml;  }, 1000);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/movies/index..html"/>
      <url>/movies/index..html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>歌单</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<p>#歌单</p><div class="aplayer" data-id="1294951288" data-server="netease" data-type="song" data-mutex="true" data-preload="auto" data-theme="#3F51B5"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>picture</title>
      <link href="/picture/index.html"/>
      <url>/picture/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
